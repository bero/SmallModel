(*****************************************)
(*      This file is autogenerated       *)
(*   Any manual changes will be LOST!    *)
(*****************************************)
(* Generated 28.12.2018 23:55:21         *)
(*****************************************)
(* This file should be stored in the     *)
(* same directory as the form/datamodule *)
(* with the corresponding model          *)
(*****************************************)
(* Copyright notice:                     *)
(*                                       *)
(*****************************************)

unit BusinessClasses;

{$INCLUDE Attracs.inc} //PATCH

interface

uses
  BoldSystem,
  SmallInterfaces;

type
  TBusinessClassesRoot = class(TBoldObject)
  private
  protected
  public
  end;

{$IFDEF UseBoldListEnumerator}
  TBusinessClassesRootListEnumerator = class(TBoldObjectListEnumerator)
  public
    function GetCurrent: TBusinessClassesRoot;
    property Current: TBusinessClassesRoot read GetCurrent;
  end;
{$ENDIF UseBoldListEnumerator}

  TBusinessClassesRootList = class(TBoldObjectList)
  protected
    function GetBoldObject(index: Integer): TBusinessClassesRoot;
    procedure SetBoldObject(index: Integer; NewObject: TBusinessClassesRoot);
  public
{$IFDEF UseBoldListEnumerator}
    function GetEnumerator: TBusinessClassesRootListEnumerator;
{$ENDIF UseBoldListEnumerator}
    function Includes(anObject: TBusinessClassesRoot): Boolean;
    function IndexOf(anObject: TBusinessClassesRoot): Integer;
    procedure Add(NewObject: TBusinessClassesRoot);
    function AddNew: TBusinessClassesRoot;
    procedure Insert(index: Integer; NewObject: TBusinessClassesRoot);
    property BoldObjects[index: Integer]: TBusinessClassesRoot read GetBoldObject write SetBoldObject; default;
  end;

{$IFDEF UseBoldListEnumerator}
  TClassAListEnumerator = class(TBoldObjectListEnumerator)
  public
    function GetCurrent: IClassA;
    property Current: IClassA read GetCurrent;
  end;
{$ENDIF UseBoldListEnumerator}

  TClassAList = class(TBusinessClassesRootList)
  protected
    function GetBoldObject(index: Integer): IClassA;
    procedure SetBoldObject(index: Integer; NewObject: IClassA);
  public
{$IFDEF UseBoldListEnumerator}
    function GetEnumerator: TClassAListEnumerator;
{$ENDIF UseBoldListEnumerator}
    function Includes(anObject: IClassA): Boolean;
    function IndexOf(anObject: IClassA): Integer;
    procedure Add(NewObject: IClassA);
    function AddNew: IClassA;
    procedure Insert(index: Integer; NewObject: IClassA);
    property BoldObjects[index: Integer]: IClassA read GetBoldObject write SetBoldObject; default;
  end;

{$IFDEF UseBoldListEnumerator}
  TClassBListEnumerator = class(TBoldObjectListEnumerator)
  public
    function GetCurrent: IClassB;
    property Current: IClassB read GetCurrent;
  end;
{$ENDIF UseBoldListEnumerator}

  TClassBList = class(TBusinessClassesRootList)
  protected
    function GetBoldObject(index: Integer): IClassB;
    procedure SetBoldObject(index: Integer; NewObject: IClassB);
  public
{$IFDEF UseBoldListEnumerator}
    function GetEnumerator: TClassBListEnumerator;
{$ENDIF UseBoldListEnumerator}
    function Includes(anObject: IClassB): Boolean;
    function IndexOf(anObject: IClassB): Integer;
    procedure Add(NewObject: IClassB);
    function AddNew: IClassB;
    procedure Insert(index: Integer; NewObject: IClassB);
    property BoldObjects[index: Integer]: IClassB read GetBoldObject write SetBoldObject; default;
  end;

{$IFDEF UseBoldListEnumerator}
  TClassBClassAListEnumerator = class(TBoldObjectListEnumerator)
  public
    function GetCurrent: IClassBClassA;
    property Current: IClassBClassA read GetCurrent;
  end;
{$ENDIF UseBoldListEnumerator}

  TClassBClassAList = class(TBusinessClassesRootList)
  protected
    function GetBoldObject(index: Integer): IClassBClassA;
    procedure SetBoldObject(index: Integer; NewObject: IClassBClassA);
  public
{$IFDEF UseBoldListEnumerator}
    function GetEnumerator: TClassBClassAListEnumerator;
{$ENDIF UseBoldListEnumerator}
    function Includes(anObject: IClassBClassA): Boolean;
    function IndexOf(anObject: IClassBClassA): Integer;
    procedure Add(NewObject: IClassBClassA);
    function AddNew: IClassBClassA;
    procedure Insert(index: Integer; NewObject: IClassBClassA);
    property BoldObjects[index: Integer]: IClassBClassA read GetBoldObject write SetBoldObject; default;
  end;

const
  BoldMemberAssertInvalidObjectType: string = 'Object of singlelink (%s.%s) is of wrong type (is %s, should be %s)';

{ TBusinessClassesRoot }

implementation

procedure TBusinessClassesRootList.Add(NewObject: TBusinessClassesRoot);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TBusinessClassesRootList.IndexOf(anObject: TBusinessClassesRoot): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TBusinessClassesRootList.Includes(anObject: TBusinessClassesRoot) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TBusinessClassesRootList.AddNew: TBusinessClassesRoot;
begin
  result := TBusinessClassesRoot(InternalAddNew);
end;

procedure TBusinessClassesRootList.Insert(index: Integer; NewObject: TBusinessClassesRoot);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TBusinessClassesRootList.GetBoldObject(index: Integer): TBusinessClassesRoot;
begin
  result := TBusinessClassesRoot(GetElement(index));
end;

procedure TBusinessClassesRootList.SetBoldObject(index: Integer; NewObject: TBusinessClassesRoot);
begin;
  SetElement(index, NewObject);
end;

{$IFDEF UseBoldListEnumerator}
function TBusinessClassesRootList.GetEnumerator: TBusinessClassesRootListEnumerator;
begin
  Result := TBusinessClassesRootListEnumerator.Create(Self);
end;

function TBusinessClassesRootListEnumerator.GetCurrent: TBusinessClassesRoot;
begin
 Result := List[Index] as TBusinessClassesRoot;
end;
{$ENDIF UseBoldListEnumerator}

procedure TClassAList.Add(NewObject: IClassA);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TClassAList.IndexOf(anObject: IClassA): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TClassAList.Includes(anObject: IClassA) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TClassAList.AddNew: TClassA;
begin
  result := TClassA(InternalAddNew);
end;

procedure TClassAList.Insert(index: Integer; NewObject: TClassA);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TClassAList.GetBoldObject(index: Integer): TClassA;
begin
  result := TClassA(GetElement(index));
end;

procedure TClassAList.SetBoldObject(index: Integer; NewObject: TClassA);
begin;
  SetElement(index, NewObject);
end;

{$IFDEF UseBoldListEnumerator}
function TClassAList.GetEnumerator: TClassAListEnumerator;
begin
  Result := TClassAListEnumerator.Create(Self);
end;

function TClassAListEnumerator.GetCurrent: TClassA;
begin
 Result := List[Index] as TClassA;
end;
{$ENDIF UseBoldListEnumerator}

{ TClassB }

function TClassB._Get_M_price: TBACurrency;
begin
  assert(ValidateMember('TClassB', 'price', 0, TBACurrency));
  Result := TBACurrency(BoldMembers[0]);
end;

function TClassB._Getprice: Currency;
begin
  Result := M_price.AsCurrency;
end;

procedure TClassB._Setprice(const NewValue: Currency);
begin
  M_price.AsCurrency := NewValue;
end;

function TClassB._GetClassAs: TClassAList;
begin
  assert(ValidateMember('TClassB', 'ClassAs', 1, TClassAList));
  Result := TClassAList(BoldMembers[1]);
end;

function TClassB._GetClassBClassA: TClassBClassAList;
begin
  assert(ValidateMember('TClassB', 'ClassBClassA', 2, TClassBClassAList));
  Result := TClassBClassAList(BoldMembers[2]);
end;

procedure TClassBList.Add(NewObject: TClassB);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TClassBList.IndexOf(anObject: TClassB): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TClassBList.Includes(anObject: TClassB) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TClassBList.AddNew: TClassB;
begin
  result := TClassB(InternalAddNew);
end;

procedure TClassBList.Insert(index: Integer; NewObject: TClassB);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TClassBList.GetBoldObject(index: Integer): TClassB;
begin
  result := TClassB(GetElement(index));
end;

procedure TClassBList.SetBoldObject(index: Integer; NewObject: TClassB);
begin;
  SetElement(index, NewObject);
end;

{$IFDEF UseBoldListEnumerator}
function TClassBList.GetEnumerator: TClassBListEnumerator;
begin
  Result := TClassBListEnumerator.Create(Self);
end;

function TClassBListEnumerator.GetCurrent: TClassB;
begin
 Result := List[Index] as TClassB;
end;
{$ENDIF UseBoldListEnumerator}

{ TClassBClassA }

function TClassBClassA._Get_M_ClassAs: TBoldObjectReference;
begin
  assert(ValidateMember('TClassBClassA', 'ClassAs', 0, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[0]);
end;

function TClassBClassA._GetClassAs: TClassA;
begin
  Result := TClassA(M_ClassAs.BoldObject);
  assert(not assigned(Result) or (Result is TClassA), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'ClassAs', Result.ClassName, 'TClassA']));
end;

function TClassBClassA._Get_M_ClassBs: TBoldObjectReference;
begin
  assert(ValidateMember('TClassBClassA', 'ClassBs', 1, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[1]);
end;

function TClassBClassA._GetClassBs: TClassB;
begin
  Result := TClassB(M_ClassBs.BoldObject);
  assert(not assigned(Result) or (Result is TClassB), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'ClassBs', Result.ClassName, 'TClassB']));
end;

procedure TClassBClassAList.Add(NewObject: TClassBClassA);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TClassBClassAList.IndexOf(anObject: TClassBClassA): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TClassBClassAList.Includes(anObject: TClassBClassA) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TClassBClassAList.AddNew: TClassBClassA;
begin
  result := TClassBClassA(InternalAddNew);
end;

procedure TClassBClassAList.Insert(index: Integer; NewObject: TClassBClassA);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TClassBClassAList.GetBoldObject(index: Integer): TClassBClassA;
begin
  result := TClassBClassA(GetElement(index));
end;

procedure TClassBClassAList.SetBoldObject(index: Integer; NewObject: TClassBClassA);
begin;
  SetElement(index, NewObject);
end;

{$IFDEF UseBoldListEnumerator}
function TClassBClassAList.GetEnumerator: TClassBClassAListEnumerator;
begin
  Result := TClassBClassAListEnumerator.Create(Self);
end;

function TClassBClassAListEnumerator.GetCurrent: TClassBClassA;
begin
 Result := List[Index] as TClassBClassA;
end;
{$ENDIF UseBoldListEnumerator}

function GeneratedCodeCRC: String;
begin
  result := '1773212761';
end;

procedure InstallObjectListClasses(BoldObjectListClasses: TBoldGeneratedClassList);
begin
  BoldObjectListClasses.AddObjectEntry('BusinessClassesRoot', TBusinessClassesRootList);
  BoldObjectListClasses.AddObjectEntry('ClassA', TClassAList);
  BoldObjectListClasses.AddObjectEntry('ClassB', TClassBList);
  BoldObjectListClasses.AddObjectEntry('ClassBClassA', TClassBClassAList);
end;

procedure InstallBusinessClasses(BoldObjectClasses: TBoldGeneratedClassList);
begin
  BoldObjectClasses.AddObjectEntry('BusinessClassesRoot', TBusinessClassesRoot);
  BoldObjectClasses.AddObjectEntry('ClassA', TClassA);
  BoldObjectClasses.AddObjectEntry('ClassB', TClassB);
  BoldObjectClasses.AddObjectEntry('ClassBClassA', TClassBClassA);
end;

var
  CodeDescriptor: TBoldGeneratedCodeDescriptor;

initialization
  CodeDescriptor := GeneratedCodes.AddGeneratedCodeDescriptorWithFunc('BusinessClasses', InstallBusinessClasses, InstallObjectListClasses, GeneratedCodeCRC);
finalization
  GeneratedCodes.Remove(CodeDescriptor);
end.

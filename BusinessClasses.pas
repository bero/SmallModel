(*****************************************)
(*      This file is autogenerated       *)
(*   Any manual changes will be LOST!    *)
(*****************************************)
(* Generated 28.12.2018 23:55:21         *)
(*****************************************)
(* This file should be stored in the     *)
(* same directory as the form/datamodule *)
(* with the corresponding model          *)
(*****************************************)
(* Copyright notice:                     *)
(*                                       *)
(*****************************************)

unit BusinessClasses;

{$DEFINE BusinessClasses_unitheader}
{$INCLUDE BusinessClasses_Interface.inc}

{ Includefile for methodimplementations }


const
  BoldMemberAssertInvalidObjectType: string = 'Object of singlelink (%s.%s) is of wrong type (is %s, should be %s)';

{ TBusinessClassesRoot }

procedure TBusinessClassesRootList.Add(NewObject: TBusinessClassesRoot);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TBusinessClassesRootList.IndexOf(anObject: TBusinessClassesRoot): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TBusinessClassesRootList.Includes(anObject: TBusinessClassesRoot) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TBusinessClassesRootList.AddNew: TBusinessClassesRoot;
begin
  result := TBusinessClassesRoot(InternalAddNew);
end;

procedure TBusinessClassesRootList.Insert(index: Integer; NewObject: TBusinessClassesRoot);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TBusinessClassesRootList.GetBoldObject(index: Integer): TBusinessClassesRoot;
begin
  result := TBusinessClassesRoot(GetElement(index));
end;

procedure TBusinessClassesRootList.SetBoldObject(index: Integer; NewObject: TBusinessClassesRoot);
begin;
  SetElement(index, NewObject);
end;

{$IFDEF UseBoldListEnumerator}
function TBusinessClassesRootList.GetEnumerator: TBusinessClassesRootListEnumerator;
begin
  Result := TBusinessClassesRootListEnumerator.Create(Self);
end;

function TBusinessClassesRootListEnumerator.GetCurrent: TBusinessClassesRoot;
begin
 Result := List[Index] as TBusinessClassesRoot;
end;
{$ENDIF UseBoldListEnumerator}

{ TClassA }

function TClassA._Get_M_name: TBAString;
begin
  assert(ValidateMember('TClassA', 'name', 0, TBAString));
  Result := TBAString(BoldMembers[0]);
end;

function TClassA._Getname: String;
begin
  Result := M_name.AsString;
end;

procedure TClassA._Setname(const NewValue: String);
begin
  M_name.AsString := NewValue;
end;

function TClassA._Get_M_price: TBACurrency;
begin
  assert(ValidateMember('TClassA', 'price', 1, TBACurrency));
  Result := TBACurrency(BoldMembers[1]);
end;

function TClassA._Getprice: Currency;
begin
  Result := M_price.AsCurrency;
end;

function TClassA._GetClassBs: TClassBList;
begin
  assert(ValidateMember('TClassA', 'ClassBs', 2, TClassBList));
  Result := TClassBList(BoldMembers[2]);
end;

function TClassA._GetClassBClassA: TClassBClassAList;
begin
  assert(ValidateMember('TClassA', 'ClassBClassA', 3, TClassBClassAList));
  Result := TClassBClassAList(BoldMembers[3]);
end;

procedure TClassAList.Add(NewObject: TClassA);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TClassAList.IndexOf(anObject: TClassA): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TClassAList.Includes(anObject: TClassA) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TClassAList.AddNew: TClassA;
begin
  result := TClassA(InternalAddNew);
end;

procedure TClassAList.Insert(index: Integer; NewObject: TClassA);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TClassAList.GetBoldObject(index: Integer): TClassA;
begin
  result := TClassA(GetElement(index));
end;

procedure TClassAList.SetBoldObject(index: Integer; NewObject: TClassA);
begin;
  SetElement(index, NewObject);
end;

{$IFDEF UseBoldListEnumerator}
function TClassAList.GetEnumerator: TClassAListEnumerator;
begin
  Result := TClassAListEnumerator.Create(Self);
end;

function TClassAListEnumerator.GetCurrent: TClassA;
begin
 Result := List[Index] as TClassA;
end;
{$ENDIF UseBoldListEnumerator}

{ TClassB }

function TClassB._Get_M_price: TBACurrency;
begin
  assert(ValidateMember('TClassB', 'price', 0, TBACurrency));
  Result := TBACurrency(BoldMembers[0]);
end;

function TClassB._Getprice: Currency;
begin
  Result := M_price.AsCurrency;
end;

procedure TClassB._Setprice(const NewValue: Currency);
begin
  M_price.AsCurrency := NewValue;
end;

function TClassB._GetClassAs: TClassAList;
begin
  assert(ValidateMember('TClassB', 'ClassAs', 1, TClassAList));
  Result := TClassAList(BoldMembers[1]);
end;

function TClassB._GetClassBClassA: TClassBClassAList;
begin
  assert(ValidateMember('TClassB', 'ClassBClassA', 2, TClassBClassAList));
  Result := TClassBClassAList(BoldMembers[2]);
end;

procedure TClassBList.Add(NewObject: TClassB);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TClassBList.IndexOf(anObject: TClassB): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TClassBList.Includes(anObject: TClassB) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TClassBList.AddNew: TClassB;
begin
  result := TClassB(InternalAddNew);
end;

procedure TClassBList.Insert(index: Integer; NewObject: TClassB);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TClassBList.GetBoldObject(index: Integer): TClassB;
begin
  result := TClassB(GetElement(index));
end;

procedure TClassBList.SetBoldObject(index: Integer; NewObject: TClassB);
begin;
  SetElement(index, NewObject);
end;

{$IFDEF UseBoldListEnumerator}
function TClassBList.GetEnumerator: TClassBListEnumerator;
begin
  Result := TClassBListEnumerator.Create(Self);
end;

function TClassBListEnumerator.GetCurrent: TClassB;
begin
 Result := List[Index] as TClassB;
end;
{$ENDIF UseBoldListEnumerator}

{ TClassBClassA }

function TClassBClassA._Get_M_ClassAs: TBoldObjectReference;
begin
  assert(ValidateMember('TClassBClassA', 'ClassAs', 0, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[0]);
end;

function TClassBClassA._GetClassAs: TClassA;
begin
  Result := TClassA(M_ClassAs.BoldObject);
  assert(not assigned(Result) or (Result is TClassA), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'ClassAs', Result.ClassName, 'TClassA']));
end;

function TClassBClassA._Get_M_ClassBs: TBoldObjectReference;
begin
  assert(ValidateMember('TClassBClassA', 'ClassBs', 1, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[1]);
end;

function TClassBClassA._GetClassBs: TClassB;
begin
  Result := TClassB(M_ClassBs.BoldObject);
  assert(not assigned(Result) or (Result is TClassB), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'ClassBs', Result.ClassName, 'TClassB']));
end;

procedure TClassBClassAList.Add(NewObject: TClassBClassA);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TClassBClassAList.IndexOf(anObject: TClassBClassA): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TClassBClassAList.Includes(anObject: TClassBClassA) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TClassBClassAList.AddNew: TClassBClassA;
begin
  result := TClassBClassA(InternalAddNew);
end;

procedure TClassBClassAList.Insert(index: Integer; NewObject: TClassBClassA);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TClassBClassAList.GetBoldObject(index: Integer): TClassBClassA;
begin
  result := TClassBClassA(GetElement(index));
end;

procedure TClassBClassAList.SetBoldObject(index: Integer; NewObject: TClassBClassA);
begin;
  SetElement(index, NewObject);
end;

{$IFDEF UseBoldListEnumerator}
function TClassBClassAList.GetEnumerator: TClassBClassAListEnumerator;
begin
  Result := TClassBClassAListEnumerator.Create(Self);
end;

function TClassBClassAListEnumerator.GetCurrent: TClassBClassA;
begin
 Result := List[Index] as TClassBClassA;
end;
{$ENDIF UseBoldListEnumerator}

function GeneratedCodeCRC: String;
begin
  result := '1773212761';
end;

procedure InstallObjectListClasses(BoldObjectListClasses: TBoldGeneratedClassList);
begin
  BoldObjectListClasses.AddObjectEntry('BusinessClassesRoot', TBusinessClassesRootList);
  BoldObjectListClasses.AddObjectEntry('ClassA', TClassAList);
  BoldObjectListClasses.AddObjectEntry('ClassB', TClassBList);
  BoldObjectListClasses.AddObjectEntry('ClassBClassA', TClassBClassAList);
end;

procedure InstallBusinessClasses(BoldObjectClasses: TBoldGeneratedClassList);
begin
  BoldObjectClasses.AddObjectEntry('BusinessClassesRoot', TBusinessClassesRoot);
  BoldObjectClasses.AddObjectEntry('ClassA', TClassA);
  BoldObjectClasses.AddObjectEntry('ClassB', TClassB);
  BoldObjectClasses.AddObjectEntry('ClassBClassA', TClassBClassA);
end;

var
  CodeDescriptor: TBoldGeneratedCodeDescriptor;

initialization
  CodeDescriptor := GeneratedCodes.AddGeneratedCodeDescriptorWithFunc('BusinessClasses', InstallBusinessClasses, InstallObjectListClasses, GeneratedCodeCRC);
finalization
  GeneratedCodes.Remove(CodeDescriptor);
end.
